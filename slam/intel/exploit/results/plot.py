#!/bin/python3

from pprint import pprint
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import sys

GADGETS = ["proc_single_show", "cgroup_seqfile_show", # "kernfs_fop_read_iter",
	"raw_seq_start", "kernfs_seq_show", "sel_read_mls", "shmem_statfs"]

data = {
	gadget: [
		[], # kaslr
		[], # bhi
		[], # find
		[], # leak
		[], # success
		[], # total
	]
	for gadget in GADGETS
}
KASLR = 0; BHI = 1; FIND = 2; LEAK = 3; SUCCESS = 4; TOTAL = 5
MINUTE = 60

with open("multiple-gadgets.out", "r") as f:
	phase = 6
	for line in f:
		words = line.split()
		if len(words) == 0:
			continue
		if words[0] == "Gadget:":
			gadget = words[1]
			assert(gadget in GADGETS)
			assert(phase == 6)
			phase = 0
		if words[0] == "Step":
			duration = float(words[2])
			data[gadget][phase].append(duration / MINUTE) # kaslr/bhi/find/leak
			phase += 1
		if words[0] == "root:$y$j9T$K3dJHvmDuvbvmpgMBL.7a1$jPsTrzyarO1f30RlG4e.c1dWA30QS1ErDzdUrHknW/8:19486:0:99999:7:::":
			data[gadget][phase].append(True) # success
			phase += 1
		if words[0] == "Took":
			if phase == SUCCESS:
				data[gadget][SUCCESS].append(False)
				phase += 1
			assert(phase == TOTAL)
			data[gadget][TOTAL].append(float(words[1]) / MINUTE)
			phase += 1
		if words[0] == "EXITING":
			if words[4] == "BHI" or line == "EXITING DUE TO ERROR: did not find the shadow file\n":
				assert(phase == 2)
				data[gadget][FIND].append(-1.0)
				data[gadget][LEAK].append(-1.0)
				data[gadget][SUCCESS].append(False)
				data[gadget][TOTAL].append(-1.0)
				phase += 4
			elif line == "EXITING DUE TO ERROR: leaked wrong (non-ascii) bytes\n" or line == "EXITING DUE TO ERROR: too much rewinding; giving up\n":
				assert(phase == 3)
				data[gadget][LEAK].append(-1.0)
				data[gadget][SUCCESS].append(False)
				data[gadget][TOTAL].append(-1.0)
				phase += 3
			else:
				print(f"UNRECOGNIZED EXIT: {line}")
				exit(1)

NR_RUNS = len(data[GADGETS[0]][0])

for gadget in GADGETS:
	for phase in range(6):
		if len(data[gadget][phase]) != NR_RUNS:
			pprint(data)
			print(f"DATA MISSING: at gadget {gadget}, phase {phase} ({data[gadget][phase]} should have length {NR_RUNS})")
			exit(1)

avg = {phase: [] for phase in range(4)}
std = {phase: [] for phase in range(4)}
leakage_rate = {} # gadget: leakage rate in B/s
gadgets = []
nr_bytes = len("root:$y$j9T$K3dJHvmDuvbvmpgMBL.7a1$jPsTrzyarO1f30RlG4e.c1dWA30QS1ErDzdUrHknW/8:19486:0:99999:7:::\n")
print(f"nr_bytes: {nr_bytes}")

for gadget in GADGETS:
	d = np.array(data[gadget])
	nr_success = int(np.sum(d[SUCCESS]))
	success_rate = nr_success / NR_RUNS
	print(f"{gadget:20} successfull exploits: {nr_success} / {NR_RUNS} ({success_rate})")
	if nr_success > 0:
		gadgets.append(gadget)
		for phase in range(4):
			vals = []
			for i in range(NR_RUNS):
				if d[SUCCESS][i]:
					vals.append(d[phase][i])
			avg[phase].append(np.average(vals) / success_rate)
			std[phase].append(np.std(vals) / success_rate)
		leakage_rate[gadget] = nr_bytes / (np.average(vals) * MINUTE)


kernfs_fop_read_iter = [[], [], [], []]
phase = 0
with open("kernfs_fop_read_iter.out", "r") as f:
	for line in f:
		words = line.split()
		if len(words) > 0 and words[0] == "Step":
			kernfs_fop_read_iter[phase].append(float(words[2]) / MINUTE)
			phase = (phase + 1) % 4
gadgets.insert(1, "kernfs_fop_read_iter")
for phase in range(4):
	avg[phase].insert(1, np.average(kernfs_fop_read_iter[phase]))
	std[phase].insert(1, np.std(kernfs_fop_read_iter[phase]))
leakage_rate["kernfs_fop_read_iter"] = nr_bytes / (np.average(kernfs_fop_read_iter[3]) * MINUTE)


columns = {0: "KASLR Break", 1: "BHI Setup", 2: "Find /etc/shadow", 3: "Leak /etc/shadow"}
index = {i: gadgets[i] for i in range(len(gadgets))}
avg = pd.DataFrame(avg).rename(columns=columns, index=index, errors="raise")
std = pd.DataFrame(std).rename(columns=columns, index=index, errors="raise")

print("---\nAverage Times:")
print(avg)
print("---\nStandard Deviations:")
print(std)

print("---\nRelative Standard Deviations:")
for i in range(len(gadgets)):
	for j in range(4):
		if avg.iat[i,j] == 0.0:
			relstd = 0.0
		else:
			relstd = 100.* std.iat[i,j] / avg.iat[i,j]
		print(f"{relstd:10.4}%", end="")
	print()

print("---\nLeakage Rates: (TODO THIS IS WRONG NOW DUE TO SUCCESS RATES AND MINUTES/SECONDS)")
for gadget in gadgets:
	print(f"{gadget:20} {leakage_rate[gadget]:8.2f} B/s")
# 	# We leaked 62 bytes of /etc/shadow
# 	nr_bytes = len("root:$y$j9T$K3dJHvmDuvbvmpgMBL.7a1$jPsTrzyarO1f30RlG4e.c1dWA30QS1ErDzdUrHknW/8:19486:0:99999:7:::\n")
# 	nr_bytes = 62
# 	seconds = avg["Leak /etc/shadow"][gadget] * MINUTE
# 	rate = nr_bytes / seconds
# 	print(f"{gadget:20} {rate:8.2f} B/s")

# print("XXXXXXXXXXXXXXXXXXXX")
# print(leakage_rate)

print("---\nEnd-to-End Times:")
for gadget in gadgets:
	e2e_time = avg["KASLR Break"][gadget]+avg["BHI Setup"][gadget]+ \
			avg["Find /etc/shadow"][gadget]+avg["Leak /etc/shadow"][gadget]
	print(f"{gadget:20} {e2e_time:8.1f} m")

ax = avg.plot.barh(stacked=True, figsize=(8,2.5), width=0.8)
ax.set_xlabel("Duration by Attack Phase (minutes)")
ax.spines['right'].set_visible(False)
ax.spines['top'].set_visible(False)
ax.legend(loc='upper right')
ax.set_xticks(range(0,10))
vals = ax.get_xticks()
for tick in vals:
	ax.axvline(x=tick, linestyle='dashed', alpha=0.4, color='#eeeeee', zorder=1)
plt.savefig("e2e-times.pdf", format="pdf", bbox_inches="tight")
plt.show()
